#include <iostream>
#include <sstream>
#include <string>
using namespace std;

class Network {

private:
    string ipString;        // input IP address as string
    int prefixLength;       // subnet prefix (CIDR)
    int numSystems;         // number of hosts to allocate

    int ip[4];              // IP split into 4 octets
    int netmask[4];         // subnet mask
    int networkIP[4];       // network address
    int broadcastIP[4];     // broadcast address

    // Split IP string into 4 integers
    void splitIP(const string& ipStr, int arr[]) {
        stringstream ss(ipStr);
        string part;
        int i = 0;
        while (getline(ss, part, '.')) {
            arr[i++] = stoi(part);
        }
    }

    // Convert 4 integers to a dotted IP string
    string ipToString(const int arr[]) const {
        return to_string(arr[0]) + "." + to_string(arr[1]) + "." +
               to_string(arr[2]) + "." + to_string(arr[3]);
    }

    // Generate subnet mask from prefix length
    void calculateMask(int prefix, int mask[]) {
        int bits = prefix;
        for (int i = 0; i < 4; i++) {

            if (bits >= 8) {             // full 8 bits = 255
                mask[i] = 255;
                bits -= 8;
            } 
            else {
                if (bits == 0)           // no bits left
                    mask[i] = 0;
                else                     // partial mask value
                    mask[i] = 256 - (1 << (8 - bits));
                bits = 0;
            }
        }
    }

    // Network address = IP AND mask
    void calculateNetworkAddress(int ip[], int mask[], int net[]) {
        for (int i = 0; i < 4; i++)
            net[i] = ip[i] & mask[i];
    }

    // Broadcast address = network address + host max value
    void calculateBroadcast(int net[], int prefix, int broad[]) {
        int hostBits = 32 - prefix;               // number of host bits
        int hostCount = (1 << hostBits) - 1;      // max host value

        for (int i = 0; i < 4; i++)
            broad[i] = net[i];

        // Add hostCount to network address (handle overflow)
        int carry = hostCount;
        for (int i = 3; i >= 0 && carry > 0; i--) {
            int val = broad[i] + carry;
            broad[i] = val % 256;
            carry = val / 256;
        }
    }

    // Add any integer offset to an IP (for usable IPs)
    void addToIP(const int addr[], int offset, int result[]) {
        for (int i = 0; i < 4; i++)
            result[i] = addr[i];

        int carry = offset;
        for (int i = 3; i >= 0 && carry > 0; i--) {
            int val = result[i] + carry;
            result[i] = val % 256;
            carry = val / 256;
        }
    }

    // Determine Class A/B/C/D/E based on first octet
    string getClass() {
        int first = ip[0];

        if (first >= 1 && first <= 126) return "Class A";
        if (first >= 128 && first <= 191) return "Class B";
        if (first >= 192 && first <= 223) return "Class C";
        if (first >= 224 && first <= 239) return "Class D (Multicast)";
        if (first >= 240 && first <= 255) return "Class E (Experimental)";
        return "Unknown";
    }

public:

    // Constructor initializes required values
    Network(const string& ipS, int prefix, int systems)
        : ipString(ipS), prefixLength(prefix), numSystems(systems)
    {
        splitIP(ipString, ip);                              // convert IP string
        calculateMask(prefixLength, netmask);               // create mask
        calculateNetworkAddress(ip, netmask, networkIP);    // compute network
        calculateBroadcast(networkIP, prefixLength, broadcastIP); // compute broadcast
    }

    // Calculate usable host count
    int maxHosts() const {
        int hostBits = 32 - prefixLength;
        if (hostBits < 2) return 0;           // no usable IPs
        return (1 << hostBits) - 2;           // usable = total - network - broadcast
    }

    // Display subnet information
    void displayDetails() {
        int firstUsable[4], lastUsable[4];

        addToIP(networkIP, 1, firstUsable);       // network + 1
        addToIP(broadcastIP, -1, lastUsable);     // broadcast - 1

        cout << "\n--- Subnet Details for " << ipString << "/" << prefixLength << " ---\n";
        cout << "IP Class        : " << getClass() << endl;
        cout << "Subnet Mask     : " << ipToString(netmask) << endl;
        cout << "Network Address : " << ipToString(networkIP) << endl;
        cout << "Broadcast Addr  : " << ipToString(broadcastIP) << endl;
        cout << "Usable Hosts    : " << maxHosts() << endl;

        if (maxHosts() > 0) {
            cout << "First Usable    : " << ipToString(firstUsable) << endl;
            cout << "Last Usable     : " << ipToString(lastUsable) << endl;
        }
        cout << endl;
    }

    // Allocate IPs to systems sequentially
    void allocateIPs() {
        int maxH = maxHosts();

        if (numSystems > maxH) {
            cout << "Cannot allocate " << numSystems
                 << " systems. Only " << maxH << " hosts available.\n";
            return;
        }

        cout << "Allocating IPs:\n";
        int current[4];
        addToIP(networkIP, 1, current);   // Start from first usable IP

        for (int i = 0; i < numSystems; i++) {
            cout << "  System " << i + 1 << ": " << ipToString(current) << endl;
            addToIP(current, 1, current); // move to next IP
        }
        cout << endl;
    }
};


int main() {
    int numNetworks;
    cout << "Enter number of networks: ";
    cin >> numNetworks;

    // Handle multiple networks sequentially
    for (int i = 0; i < numNetworks; i++) {
        string ip;
        int prefix, systems;

        cout << "\nNetwork " << i + 1 << ":\n";
        cout << "Enter IP (example 192.168.1.0): ";
        cin >> ip;
        cout << "Enter prefix (example 24): ";
        cin >> prefix;
        cout << "Enter number of systems: ";
        cin >> systems;

        Network net(ip, prefix, systems);

        net.displayDetails();   // show calculated details
        net.allocateIPs();      // allocate IPs
    }

    return 0;
}
